function [final_phased_Paths_all, final_phased_Paths_unique] = fix_Phasing(ToF_Paths,MA_threshold, Grid, IOCombination, idx_shift)

%fix_Phasing.m - Fix paths' phasing
%
%DESCRIPTION:
%Step 4 of the AUTOMATE algorithm, fixes the phasing of the paths. 
% CAUTION: this step is inaccurate and should not be used in the AUTOMATE's
% process
%
%INPUTS
%-ToF_Paths:
%   List of paths cell generated by generate_PathsToF.m
%-MA_threshold (rad):
%   Threshold allowed for the Mean anomaly
%-Grid:
%   Grid generated by generate_grid.m
%-IOCombination:
%   List of possible IO transfers generated by generate_IOCombinations.m
%-idx_shift:
%   Shift in index to select the right IO combination list, provided by 
%   generate_IOCombinations.m
%
%OUTPUTS
%-final_phased_Paths_all:
%   Cell containing the list of paths for different I/O combination, with
%   the I/O combination used, the ToFs of each leg and the total ToF
%-final_phased_Paths_unique:
%   Cell containing the list of sequences that pass the phasing check 
%
%AUTHOR
%Hadrien AFSA
%
%--------------------------------------------------------------------------
    
    muSun=getAstroConstants('Sun', 'mu');
    
    phased_Paths=cell(size(ToF_Paths,1),4);
    idx_path=1;
    phased_Paths_unique=cell(size(ToF_Paths,1),1);
    unique_idx=1;

    for i=1:size(ToF_Paths,1)
        % Current sequence and all ToFs
        current_seq=ToF_Paths{i,1};
        list_ToFs=ToF_Paths{i,2};
        length_curr_seq=size(current_seq,1);

        % Takes the list of all possible I/O combinations for the sequence length
        IOCombi=IOCombination{length_curr_seq-idx_shift};
        
        % To keep only unique sequences
        save_first_of_seq=true;
        
        % Stores the ToFs of each leg of the current seq
        ToFs_seq=zeros(1,length(list_ToFs));

        % Goes through all the possible I/O combinations
        for io=1:size(IOCombi,1)
            % Select I/O combination
            IO_list=IOCombi(io,:);

            % Creates list of Mean anomalies of the planets for the
            % meetings
            list_MA=zeros(length_curr_seq,1);
            
            % Check if one leg has wrong phasing
            wrong_phasing=false;

            % Goes through all the legs of the sequence
            for s=1:length_curr_seq-1
                %disp('####################');
                %list_MA

                % Load current leg parameters
                curr_pl     =   current_seq(s,1);
                curr_Vinf   =   current_seq(s,2);
                curr_type   =   IO_list(s);
                next_pl     =   current_seq(s+1,1);
                next_Vinf   =   current_seq(s+1,2);
                next_type   =   IO_list(s+1);
                
                % Finds the ToF of this leg
                if curr_type==0
                    if next_type==0
                        ToF_leg=list_ToFs(s,1);
                    else
                        ToF_leg=list_ToFs(s,2);
                    end
                else
                    if next_type==0
                        ToF_leg=list_ToFs(s,3);
                    else
                        ToF_leg=list_ToFs(s,4);
                    end
                end
                ToFs_seq(s)=ToF_leg;

                % Not a resonance
                if curr_pl~=next_pl
                    
                    % Find intersection on the Grid
                    inter=check_intersectionGrid(curr_pl, curr_Vinf, next_pl, next_Vinf, Grid);
                    % Gets the alpha on the corresponding Vinf contour
                    if curr_pl>next_pl
                        curr_alpha = inter(5);
                    else
                        curr_alpha = inter(2);
                    end

                    % Computes the S/C orbit parameters during the leg
                    [ra_SC, rp_SC] = alphaVinf2raRp(curr_alpha, curr_Vinf, curr_pl);
                    a_SC =(ra_SC+rp_SC)/2;
                    e_SC = ra_SC/a_SC - 1;

                    % Computes the current and next planet parameters
                    [~,~,curr_pl_sma]=planetConstants(curr_pl);
                    [~,~,next_pl_sma]=planetConstants(next_pl);   

                    % Computes initial and final true anomaly
                    theta_i=wrapTo2Pi((1-2*curr_type)*acos((1/e_SC) * ((a_SC*(1-e_SC^2)/curr_pl_sma) - 1)));
                    theta_f=wrapTo2Pi((1-2*next_type)*acos((1/e_SC) * ((a_SC*(1-e_SC^2)/next_pl_sma) - 1)));

                    % Initialises the argument of periapsis to 0
                    if s==1
                        omega=0;      
                    end
                    
                    % Writes the orbit parameters
                    kep_SC=[a_SC e_SC 0 0 omega 0];

                    % Creates the orbit parameters for the two points 
                    kep_SC_i=kep_SC;
                    kep_SC_f=kep_SC;
                    kep_SC_i(6)=theta_i;
                    kep_SC_f(6)=theta_f;
                    
                    % Computes the orbit parameters in cartesian of the two points
                    r_SC_i=kep2car(kep_SC_i,muSun);
                    r_SC_f=kep2car(kep_SC_f,muSun);

                    % Computes the Mean Anomalies based on the direction vector
                    M_curr_pl=R2MA(r_SC_i(1), r_SC_i(2));
                    M_next_pl=R2MA(r_SC_f(1), r_SC_f(2));

                    % If first leg, stores the Mean anomalies
                    if s==1
                        list_MA=[M_curr_pl M_next_pl];
                        idx_MA=3;
                        
                    else % For the other legs, computes the change of argument of periapsis
                        
                        old_M=list_MA(idx_MA-1);
                        %cur_M=M_curr_pl;
                        if abs(old_M-M_curr_pl)<pi
                            d_omega=abs(old_M-M_curr_pl);
                        else
                            d_omega=2*pi-abs(old_M-M_curr_pl);
                        end
                        
                        % Checks if the change is positive or negative
                        if isAheadOf(M_curr_pl,old_M)
                            omega=omega+d_omega;
                        else
                            omega=omega-d_omega;
                        end

                        % Updates the orbit parameters
                        %kep_SC_i(5)=omega;
                        kep_SC_f(5)=omega;

                        % Computes the new parameters in cartesian
                        %r_SC_i=kep2car(kep_SC_i,muSun);
                        r_SC_f=kep2car(kep_SC_f,muSun);

                        % Computes the new mean anomalies
                        %M_curr_pl=R2MA(r_SC_i(1), r_SC_i(2));
                        M_next_pl=R2MA(r_SC_f(1), r_SC_f(2));

                        % Adds them to the list
                        list_MA(idx_MA)=M_next_pl;
                        idx_MA=idx_MA+1;
                        %list_MA=[list_MA; [M_curr_pl M_next_pl]];
                    end
                
                else %Resonance
                    list_MA(idx_MA)=list_MA(idx_MA-1);
                    idx_MA=idx_MA+1;
                end

                
            end 
            
            % Sequence analysis finished, ToFs and MAs saved
            % Starts checking that the phasing is correct           
            list_planet_met=current_seq(:,1);
            
            % Finds repetition of planets
            for pl=2:length(list_planet_met)
                % Repetition of planet detected
                indexes=find(list_planet_met(1:pl-1)==list_planet_met(pl));
                if ~isempty(indexes)
                    % Finds the last meeting of the planet
                    pos=indexes(end);
                    
                    % Computes the rate of the planet
                    [~,~,sma_pl]=planetConstants(list_planet_met(pl)); 
                    n_pl=sqrt(muSun/(sma_pl^3));
                    
                    % The actual planet MA = last Mean anomaly + n*ToF
                    actual_MA = wrapTo2Pi(list_MA(pos) + n_pl * sum(ToFs_seq(pos:pl-1)));
                    
                    if abs(actual_MA-list_MA(pl))<pi
                        diff=abs(actual_MA-list_MA(pl));
                    else
                        diff=2*pi-abs(actual_MA-list_MA(pl));
                    end
                    %diff=abs(actual_MA-list_MA(pl))
                    
                    %fprintf('s: %d, pl: %d, diff: %f\n', io,pl,rad2deg(diff))
                    %IO_list

                    if diff>MA_threshold
                        wrong_phasing=true;
                        break
                    end
                end
            end

            if ~wrong_phasing
                %disp('this one must be saved');
                phased_Paths{idx_path,1}=ToF_Paths{i,1};
                phased_Paths{idx_path,2}=IO_list;
                phased_Paths{idx_path,3}=ToFs_seq;
                phased_Paths{idx_path,4}=sum(ToFs_seq);
                idx_path=idx_path+1;
                
                if save_first_of_seq
                    save_first_of_seq=false;
                    phased_Paths_unique{unique_idx,1}=ToF_Paths{i,1};
                    unique_idx=unique_idx+1;
                end
            else
                %disp('this one cant be saved');
            end
        end
        
        if mod(i,500)==0
            fprintf("Phasing sequences: %d/%d\n", i, size(ToF_Paths,1));
        elseif i==size(ToF_Paths,1)
            fprintf("Phasing finished!\n");
        end
    end
    
    final_phased_Paths_all=phased_Paths(~cellfun('isempty',phased_Paths(:,1)),:);
    final_phased_Paths_unique=phased_Paths_unique(~cellfun('isempty',phased_Paths_unique(:,1)),:);
 
end

