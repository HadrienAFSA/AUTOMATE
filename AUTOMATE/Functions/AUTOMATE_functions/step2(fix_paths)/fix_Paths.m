function [final_fixed_Paths] = fix_Paths(Paths, Grid,max_reso_leg, max_reso_tot)

%fix_Paths.m - Fix paths
%
%DESCRIPTION:
%Step 2 of the AUTOMATE algorithm, fixes the paths generated by Step 1 by
%checking if single flyby are possible, and by adding resonances
%
%INPUTS
%-Paths:
%   List of paths generated by generate_Paths.m
%-Grid:
%   Grid generated by generate_grid.m
%-max_reso_leg:
%   Maximum number of resonances allowed per leg
%-max_reso_tot:
%   Maximum number of resonances allowed totally
%
%OUTPUTS
%-final_fixed_Paths:
%   Cell containing the list of fixed paths, with the resonances used if
%   applicable
%
%AUTHOR
%Hadrien AFSA
%
%--------------------------------------------------------------------------

    l_Paths=length(Paths);
    
    Paths_fixed=cell(l_Paths,2);
    idx_path=1;
    
    for i=1:length(Paths)
        %disp("#################");
        tic;

        seq=Paths{i};
        impossible_sequence=false;

        seq_fixed=[seq(1,:)];
        
        % Stores all the resonances and alpha used
        list_reso_used=[]; 
        list_alpha_used=[];
        shift_reso=0;
        
        % Stores the total number of resonances used
        total_num_reso = 0;

        %plotTrip(planets, v_inf_levels, seq, Grid)

        for j=2:length(seq)-1 
            %prec=seq(j-1,:)
            %curr=seq(j,:)
            %next=seq(j+1,:)
            % Finds first and second intersections
            inter1=check_intersectionGrid(seq(j-1,1), seq(j-1,2), seq(j,1), seq(j,2), Grid);
            inter2=check_intersectionGrid(seq(j,1), seq(j,2), seq(j+1,1), seq(j+1,2), Grid);

            % Gets the initial alpha (checks which column to get it from)
            if seq(j,1)<seq(j-1,1)
                alpha_i = inter1(2);
            elseif seq(j,1)>seq(j-1,1)
                alpha_i = inter1(5);
            else
                disp("Error#1");
            end

            % Gets objective alpha
            if seq(j,1)<seq(j+1,1)
                alpha_f = inter2(2);
            elseif seq(j,1)>seq(j+1,1)
                alpha_f = inter2(5);
            else
                disp("Error#2");
            end

            % Checks if single flyby can be achieved (no resonance needed)
            if check_singleFlyby(alpha_i, alpha_f, seq(j,1), seq(j,2))
                % Single flyby can be achieved
                %disp("Single flyby possible.");
                seq_fixed=[seq_fixed; seq(j,:)];
            else
                % Try to find resonance            
                if total_num_reso < max_reso_tot
                    if max_reso_leg==0
                        impossible_sequence=true;
                        break
                    else
                        %disp('###############');
                        % Find resonances available: how many are used,
                        % what are the alpha used, and what ratio are the
                        % resonances (n:m)
                        [n_reso, alpha_list, reso_used]=check_Resonances(alpha_i, alpha_f, seq(j,1), seq(j,2),max_reso_leg);

                        if n_reso==0
                            % No possible path
                            %disp("Impossible sequence");
                            impossible_sequence=true;
                            break
                        else
                            % Adds the resonances used in a matrix to be
                            % stored
                            tmp_reso_matrix=[];
                            for r=1:size(reso_used,1)
                                tmp_reso_matrix=[tmp_reso_matrix; [reso_used(r,:) j+shift_reso]];
                                shift_reso=shift_reso+1;
                            end
                            list_reso_used=[list_reso_used; tmp_reso_matrix];
                            list_alpha_used=[list_alpha_used; [alpha_list]]; 
                            
                            % Adds the resonance flybys in the sequence
                            for reso=1:n_reso+1
                                seq_fixed=[seq_fixed; seq(j,:)];
                            end

                            total_num_reso = total_num_reso+n_reso;
                            %disp("reso added");
                            
                        end
                    end
                else
                    impossible_sequence=true;
                    %disp('nope too much');
                    break
                end
            end

        end

        % Sequence including all the resonances
        seq_fixed=[seq_fixed; seq(end,:)];

        % Saves the sequences and its parameters
        if not(impossible_sequence)
            %seq_fixed
            Paths_fixed{idx_path,1}=seq_fixed;
            Paths_fixed{idx_path,2}=list_reso_used;
            Paths_fixed{idx_path,3}=list_alpha_used;
            
            idx_path=idx_path+1;
            
        else
            %Paths_fixed=[Paths_fixed; {"Not possible"}];
        end

        if mod(i,50000)==0
            elapsed_time=toc;
            percent=(i/l_Paths)*100;
            remaining_time = round((l_Paths-i)*elapsed_time,0);
            hours_left=floor(remaining_time/3600);
            minutes_left=floor((remaining_time-hours_left*3600)/60);
            seconds_left=mod(remaining_time,60);

            fprintf("Fixing paths...: %d/%d (%g%%), ETA: %d h %d m %d s.\n", ...
                    i, l_Paths, round(percent, 1), hours_left,...
                    minutes_left, seconds_left);
        elseif i==size(Paths,1)
            fprintf("\nFixing paths finished!");
        end

    end

    final_fixed_Paths=Paths_fixed(~cellfun('isempty',Paths_fixed(:,1)),:);
    fprintf(" %d paths fixed.\n", size(final_fixed_Paths,1));
end

