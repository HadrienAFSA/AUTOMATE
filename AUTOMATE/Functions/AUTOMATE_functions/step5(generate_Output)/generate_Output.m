function [output_Paths] = generate_Output(Paths_ToF, accepted_arr_vinf)

%generate_Output.m - Generate output
%
%DESCRIPTION:
%Step 5 of the AUTOMATE algorithm, generates the output of all previous
%steps to be in a suitable format for ASTRA or any other software. Also
%acts as post-process as it can only keep selected arrival infinity
%velocities.
%
%INPUTS
%-Paths_ToF:
%   Cell containing paths generated by Step 3 (generate_PathsToF.m)
%-accepted_arr_vinf (km/s):
%   Range of accepted infinity velocity: [A B] with A being the lower bound
%   and B the upper bound. [3 7] will only keep paths with arrival velocity
%   between 3 and 7 km/s
%
%OUTPUTS
%-output_Paths:
%   Cell containing the list of sequences found, together with information
%   from the Tisserand graph (what resonances are used, ToF and Vinf
%   ranges). Format suitable for ASTRA.
%
%AUTHOR
%Hadrien AFSA
%
%--------------------------------------------------------------------------

    size_input=size(Paths_ToF,1);

    output_Paths = struct('SEQ', [], 'RES', [], 'RES_ASTRA', [], 'VINF', [], 'TOF', []);
    idx_paths = 1;

    % Finds all the different sequences and different Vinfinities
    for i=1:size_input

        % Sequence (with Vinfinities)
        seq=Paths_ToF{i,1};
        
        % Removes high arrival Vinfs
        if accepted_arr_vinf(1) <= seq(end,2) && seq(end,2) <= accepted_arr_vinf(end)
        
            % Sequence (numbers)
            seq_nbr=seq(:,1)';

            % Sequence (string)
            %seq_str=path2str(input{i,1})

            % Vinfinities
            seq_vinf = seq(:,2);


            % Finds the min and max ToF for each leg
            ToFs_list   = Paths_ToF{i,2};
            min_tof     = min(ToFs_list, [], 2)./(24*3600);
            max_tof     = max(ToFs_list, [], 2)./(24*3600);

            % Resonances
            reso_tmp = Paths_ToF{i,3};

            % Resonance matrix
            res_matrix=zeros(length(seq_nbr)-1,3);
            for res=1:size(reso_tmp,1)
                res_matrix(reso_tmp(res, 3),:)=reso_tmp(res,:);
            end

            % Resonances in final format
            resonance = reshape(reso_tmp',1,[]);

            % Checks if the sequence with the same Vinf is already in the list
            idx_seq=NaN;
            for s=1:size(output_Paths,2)
                % Exact same sequence (same resonance as well)
                if isequal(seq_nbr,output_Paths(s).SEQ) && isequal(resonance,output_Paths(s).RES_ASTRA)
                    idx_seq=s;
                    break
                end
            end

            % If the sequence is not yet in the output, saves it
            if isnan(idx_seq)
                output_Paths(idx_paths).SEQ=seq_nbr;

                output_Paths(idx_paths).RES=res_matrix;

                output_Paths(idx_paths).RES_ASTRA=resonance;

                output_Paths(idx_paths).VINF=[seq_vinf,seq_vinf];

                output_Paths(idx_paths).TOF=[min_tof,max_tof];

    %             if idx_paths<round(size_input/100)
    %                 if idx_paths==1
    %                     idx_paths=round(size_input/100)+1;
    %                 else
    %                     idx_paths=idx_paths-1;
    %                 end
    %             else
    %                 idx_paths=idx_paths+1;
    %             end  
                idx_paths=idx_paths+1;

            else % Sequence already in list
                % Extracts the Vinf and TOF matrices
                tmp_vinf=output_Paths(idx_seq).VINF;
                tmp_tof=output_Paths(idx_seq).TOF;

                for j=1:size(tmp_vinf,1)
                    % Compare the min Vinf
                    if seq_vinf(j) < tmp_vinf(j,1)
                        tmp_vinf(j,1)=seq_vinf(j);
                    end

                    % Compare the max Vinf
                    if seq_vinf(j) > tmp_vinf(j,2)
                        tmp_vinf(j,2)=seq_vinf(j);
                    end

                    % Compare the ToF
                    if j~=size(tmp_vinf,1)
                        % Compare min
                        if min_tof(j) < tmp_tof(j,1)
                            tmp_tof(j,1)=min_tof(j);
                        end

                        % Compare max
                        if max_tof(j) > tmp_tof(j,2)
                            tmp_tof(j,2)=max_tof(j);
                        end                    
                    end
                end

                % Saves the updated matrices
                output_Paths(idx_seq).VINF=tmp_vinf;
                output_Paths(idx_seq).TOF=tmp_tof;
            end

        end
        if mod(i,50000)==0
            fprintf("Generating output: %d/%d\n", i, size(Paths_ToF,1));
        end
    end
    
    for o=1:size(output_Paths,2)
        seq=output_Paths(o).SEQ;
        l_seq=length(seq);
        
        seq_tof=output_Paths(o).TOF;
        
        for s=1:l_seq-1
            pl1=seq(s);
            pl2=seq(s+1);
            
            if pl1~=pl2 %not a resonance
                [min_bound, max_bound]=find_ToFBounds(pl1,pl2);

                if seq_tof(s, 1)<min_bound
                    seq_tof(s, 1)=min_bound;
                end     

                if seq_tof(s, 2)>max_bound
                    seq_tof(s, 2)=max_bound;
                end                  
            end
            
            
        end
        output_Paths(o).TOF=seq_tof;
    end
        

    fprintf("\nGenerating output finished!\n");
end

