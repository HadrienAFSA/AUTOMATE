function [output_Paths] = generate_Output(Paths_ToF, accepted_arr_vinf)
%generate_Output.m - Generate output
%
%DESCRIPTION:
%Generates the output of all previous steps to be in a suitable format. 
%Lists all the sequences, their time of flight, launch window, DSMs, ...
%
%INPUTS
%-Paths_ToF:
%   Cell containing paths generated by Step 3 (generate_PathsToF.m)
%-accepted_arr_vinf (km/s):
%   Range of accepted infinity velocity: [A B] with A being the lower bound
%   and B the upper bound. [3 7] will only keep paths with arrival velocity
%   between 3 and 7 km/s
%
%OUTPUTS
%-output_Paths:
%   Cell containing the list of sequences found, together with information
%   from the Tisserand graph (what resonances are used, ToF (in days),  
%   Vinf ranges, ...).
%
%AUTHOR
%Hadrien AFSA
%
%--------------------------------------------------------------------------

    size_input=size(Paths_ToF,1);

    output_Paths = struct('SEQ', [], 'RES', [], 'RES_ASTRA', [], 'VINF', [], 'TOF', [], 'TOTAL_TOF', [], 'LAUNCH_DATES', [], 'NUMBER_OF_OCCURENCES', [], 'LIST_OF_OCCURENCES', []);
    idx_paths = 1;

    % Finds all the different sequences and different Vinfinities
    for i=1:size_input

        % Sequence (with Vinfinities)
        seq=Paths_ToF{i,1};
        
        % Removes high arrival Vinfs
        if accepted_arr_vinf(1) <= seq(end,2) && seq(end,2) <= accepted_arr_vinf(end)
        
            % Sequence (numbers)
            seq_nbr=seq(:,1)';

            % Sequence (string)
            %seq_str=conv_path2str(input{i,1})

            % Vinfinities
            seq_vinf = seq(:,2);

            % Finds the min and max ToF for each leg
            ToFs_list   = Paths_ToF{i,3};
            min_tof     = min(ToFs_list, [], 2)./(24*3600);
            max_tof     = max(ToFs_list, [], 2)./(24*3600);

            % Finds the min and max launch date
            min_date = min(Paths_ToF{i,4});
            max_date = max(Paths_ToF{i,4});

            % Resonances
            reso_tmp = Paths_ToF{i,2};

            % Resonance matrix
            res_matrix=zeros(length(seq_nbr)-1,3);
            for res=1:size(reso_tmp,1)
                res_matrix(reso_tmp(res, 3),:)=reso_tmp(res,:);
            end

            % Resonances in final format
            resonance = reshape(reso_tmp',1,[]);

            % Checks if the sequence with the same Vinf is already in the list
            idx_seq=NaN;
            for s=1:size(output_Paths,2)
                % Exact same sequence (same resonance as well)
                if isequal(seq_nbr,output_Paths(s).SEQ) && isequal(resonance,output_Paths(s).RES_ASTRA)
                    idx_seq=s;
                    break
                end
            end
            
            % If the sequence is not yet in the output, saves it
            if isnan(idx_seq)
                output_Paths(idx_paths).SEQ=seq_nbr;

                output_Paths(idx_paths).RES=res_matrix;

                output_Paths(idx_paths).RES_ASTRA=resonance;

                output_Paths(idx_paths).VINF=[seq_vinf,seq_vinf];

                output_Paths(idx_paths).TOF=[min_tof,max_tof];

                output_Paths(idx_paths).TOTAL_TOF=[sum(min_tof),sum(max_tof)];

                output_Paths(idx_paths).LAUNCH_DATES=[min_date,max_date];

                output_Paths(idx_paths).NUMBER_OF_OCCURENCES=[1];

                output_Paths(idx_paths).LIST_OF_OCCURENCES={'ID' 'Sequence (1D)' 'Sequence (2D)' 'Resonances used' 'ToF (s) (OO OI IO II)' 'Launch date (MJD2000) (OO OI IO II)' 'DMSs (km/s)';i conv_2Dto1D(seq) Paths_ToF{i,:}};
 
                idx_paths=idx_paths+1;

            else % Sequence already in list
                % Extracts the Vinf and TOF matrices and launch dates
                tmp_vinf=output_Paths(idx_seq).VINF;
                tmp_tof=output_Paths(idx_seq).TOF;
                tmp_launch=output_Paths(idx_seq).LAUNCH_DATES;
                tmp_nbocc=output_Paths(idx_seq).NUMBER_OF_OCCURENCES(1);

                for j=1:size(tmp_vinf,1)
                    % Compare the min Vinf
                    if seq_vinf(j) < tmp_vinf(j,1)
                        tmp_vinf(j,1)=seq_vinf(j);
                    end

                    % Compare the max Vinf
                    if seq_vinf(j) > tmp_vinf(j,2)
                        tmp_vinf(j,2)=seq_vinf(j);
                    end

                    % Compare the ToF
                    if j~=size(tmp_vinf,1)
                        % Compare min
                        if min_tof(j) < tmp_tof(j,1)
                            tmp_tof(j,1)=min_tof(j);
                        end

                        % Compare max
                        if max_tof(j) > tmp_tof(j,2)
                            tmp_tof(j,2)=max_tof(j);
                        end                    
                    end
                end

                % Compares the launch dates
                if min_date<tmp_launch(1)
                    tmp_launch(1)=min_date;
                end
                if max_date>tmp_launch(end)
                    tmp_launch(end)=max_date;
                end

                % Saves the updated matrices
                output_Paths(idx_seq).VINF=tmp_vinf;
                output_Paths(idx_seq).TOF=tmp_tof;
                output_Paths(idx_seq).TOTAL_TOF=[sum(tmp_tof(:,1)), sum(tmp_tof(:,2))];
                output_Paths(idx_seq).LAUNCH_DATES=tmp_launch;
                output_Paths(idx_seq).NUMBER_OF_OCCURENCES=[tmp_nbocc+1];
                output_Paths(idx_seq).LIST_OF_OCCURENCES(tmp_nbocc+2,:)={i conv_2Dto1D(seq) Paths_ToF{i,:}};
            end

        end
        if mod(i,50000)==0
            fprintf("Generating output: %d/%d\n", i, size(Paths_ToF,1));
        end
    end
    
    for o=1:size(output_Paths,2)
        seq=output_Paths(o).SEQ;
        l_seq=length(seq);
        
        seq_tof=output_Paths(o).TOF;
        
        for s=1:l_seq-1
            pl1=seq(s);
            pl2=seq(s+1);
            
            if pl1~=pl2 %not a resonance
                [min_bound, max_bound]=find_ToFBounds(pl1,pl2);

                if seq_tof(s, 1)<min_bound
                    seq_tof(s, 1)=min_bound;
                end     

                if seq_tof(s, 2)>max_bound
                    seq_tof(s, 2)=max_bound;
                end                  
            end
            
            
        end
        output_Paths(o).TOF=seq_tof;
    end
        

    fprintf("\nGenerating output finished!\n");
end

