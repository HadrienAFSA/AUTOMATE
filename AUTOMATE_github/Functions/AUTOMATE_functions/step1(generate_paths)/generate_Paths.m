function [paths_final] = generate_Paths(dep_planet, dep_vinf,arri_planet,arri_vinf,max_depth,Grid, planets, v_inf_levels)
%generate_Paths.m - Generate paths
%
%DESCRIPTION:
%Generates all the possible trajectories between the departure planet and 
%the arrival planet with the given infinity velocities and planets.
%
%INPUTS
%-dep_planet:
%   ID of the departure planet
%-dep_vinf (km/s):
%   List of the departure infinity velocity/ies.
%-arri_planet:
%   ID of the arrival planet
%-arri_vinf (km/s):
%   List of the arrival infinity velocity/ies.
%-max_depth:
%   Maximum depth of the tree (for the depth-limited search)
%-Grid:
%   Grid generated by generate_grid.m
%-planets:
%   List of planets ID taken into account
%-v_inf_levels (km/s):
%   List of infinity velocities taken into account
%
%OUTPUTS
%-paths_final:
%   Cell containing the list of paths
%
%AUTHOR
%Hadrien AFSA
%
%--------------------------------------------------------------------------

    % Creates departing condition
    dep=cell(size(dep_vinf,1),1);
    for i=1:length(dep_vinf)
        dep{i}= [0 dep_planet dep_vinf(i)];
    end
    dep=dep(~cellfun('isempty',dep));
    
    % Stops before error
    if ~ismember(dep{1}(3),v_inf_levels)
        error('Error in generate_Paths: starting Vinf not in V_inf_levels');
        paths_final=[];
        return
    end
    if ~ismember(arri_planet,planets)
        error('Error in generate_Paths: starting planet not in planets list');
        paths_final=[];
        return
    end
    
    n_pl=length(planets)-1;
    n_vinf=length(v_inf_levels);

    % Initialisation
    stack=cell(n_pl*n_vinf + 2*max_depth, 1);
    size_dep=size(dep,2);
    for i=1:size_dep
        stack{i}=dep{i};
    end
    stack_size=size_dep;
    temp_seq_id=[];

    % Stores paths found (allocate maximum number of paths)
    paths=cell(2, 1);
    %paths=cell((n_pl*n_vinf)^max_depth, 1);
    path_idx=1;
    
    % Track time
    number_op=0;
    first=true;
    remaining_paths1=0;
    progress=0;
    root_number=1;
    
    dep_planet=stack{1}(2);
    
    while stack_size>0
        %fprintf("#########################\n");
        %number_op=number_op+1;
        
        % Takes current node and pops it from stack
        current=stack{1};
        stack(1:stack_size-1) = stack(2:stack_size);
        stack_size=stack_size-1;

        % Sets the new depth
        depth=current(1);
        %length(temp_seq_id)
        
        % Writes the console message
        if depth==0 % One of the roots
            % Keeps the initial Vinf
            ini_vinf=current(3);
            
            if ~first
                time_root=round(toc(root_time));
                hours_root=floor(time_root/3600);
                minutes_root=floor((time_root-hours_root*3600)/60);
                seconds_root=mod(time_root,60);
                fprintf("Root time taken: %d h %d m %d s.\n\n", hours_root, minutes_root, seconds_root);
            end
            fprintf("Root %d/%d:\n", root_number, size_dep);
            root_number=root_number+1;
            first=true;
            progress=0;
        end
        if depth==1 
            if first 
                first=false;
                remaining_paths1=stack_size-size_dep+root_number-1;
                %time_list=zeros(1, remaining_paths1);
                root_time=tic;
            else
                progress=progress+1;
                
                elapsed_time=toc(time_while);
                %time_list(progress)=elapsed_time;
                percent=(progress/remaining_paths1)*100;
                remaining_time = round((remaining_paths1-progress+1)*elapsed_time);%mean(time_list(1:progress)),0)
                hours_left=floor(remaining_time/3600);
                minutes_left=floor((remaining_time-hours_left*3600)/60);
                seconds_left=mod(remaining_time,60);

                fprintf("Generating paths of root %d/%d: %d/%d (%g%%), Root ETA: %d h %d m %d s.\n", ...
                        root_number-1, size_dep, progress, remaining_paths1, ... 
                        round(percent, 1), hours_left,minutes_left, seconds_left);                
            end
            time_while=tic;
            
        end

        % Checks that the depths matches the length of the current path
        % If not, adjust it
        if size(temp_seq_id,1)~=depth
            temp_seq_id=temp_seq_id(1:depth,:);
        end
        temp_seq_id=[temp_seq_id; [current(2), current(3)]];

        %fprintf("Depth: %d, size stack = %d.\n" ,depth,length(stack));

        % Checks if current node is objective node,
        if current(2)==arri_planet && ismember(current(3),arri_vinf)
            %disp("Arrived, path added!");    
            % Adds the path to the list of all possible paths
            paths{path_idx}=temp_seq_id;
            path_idx=path_idx+1;

        elseif depth>=max_depth
            %disp("Max depth reached!");

        else
            % Generates child nodes
            new_nodes=generate_ChildNodes(current, Grid, max_depth, arri_planet);
            
            % Add the new nodes to the stack if never met before (to avoid
            % repetition and loops)
            for i=size(new_nodes,1):-1:1
                tmp=new_nodes(i,2:3);

                % Avoid repetition of Earth with lower/eq Vinf
                if tmp(1)~=dep_planet || tmp(2)>ini_vinf
                    
                    % If the node is not in the last 2 planet met
                    if size(temp_seq_id,1)>=2 && not((tmp(1)==temp_seq_id(end-1,1) && tmp(2)==temp_seq_id(end-1,2)) || (tmp(1)==temp_seq_id(end,1) && tmp(2)==temp_seq_id(end,2)))
                        stack(2:stack_size+1)=stack(1:stack_size);
                        stack{1}=new_nodes(i,:);
                        stack_size=stack_size+1;
                    elseif ~ismember(tmp,temp_seq_id, 'rows')
                        stack(2:stack_size+1)=stack(1:stack_size);
                        stack{1}=new_nodes(i,:);
                        stack_size=stack_size+1;
                    else
                        %disp("Is already member, not added");
                    end
                end
            end

            %depth
            %celldisp(stack)
            %disp("-------------------------");
        end
    end
    % Display time of last root
    time_root=round(toc(root_time));
    hours_root=floor(time_root/3600);
    minutes_root=floor((time_root-hours_root*3600)/60);
    seconds_root=mod(time_root,60);
    fprintf("Root time taken: %d h %d m %d s.\n\n", hours_root, minutes_root, seconds_root);

    
    % Removes the empty cells
    paths_final=paths;%paths_final=paths(~cellfun('isempty',paths));
    fprintf("Generating paths complete! %d paths generated.\n", size(paths_final,1));
    %fprintf('%d\n',number_op)

end

