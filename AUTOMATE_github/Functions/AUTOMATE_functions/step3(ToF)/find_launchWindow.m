function [launch_window] = find_launchWindow(pl1, pl2, theta_1, theta_2, list_ToFs, phase_database)
%find_launchWindow - Finds the launch window
% 
%DESCRIPTION:
%This script finds the closest launch date to the year specified for
%which the two planets (pl1 and pl2) have the anomalies provided (theta1
%and theta2 respectively), and for the 4 combination of Inbound/Outbound
%trajectories.
%This function is made to be used for the first leg of a transfer,
%generally starting with Earth.
% 
%INPUTS
%-pl1, pl2: 
%   ID of the planets. pl1 is the first planet of the leg, not necessarily
%   the innermost one.
%-theta1, theta2 (rad): 
%   Required anomalies of the two planets, in radians. theta1 is the
%   anomaly of the innermost planet. Therefore, theta2 can correspond to
%   pl1 and vice-versa. This is handled in the function.
%-list_ToFs (s):
%   List of the possible time of flight (Inbound/Outbound combination) of
%   the leg in seconds, in the following order: OO OI IO II.
%-phase_database:
%   Cell containing the phase angle for each couple of planet and for the 
%   whole synodic period, starting from a reference date.
%   Generated by the generate_PhaseDatabase function. See here for more
%   infos.
%
%OUTPUTS
%-launch_window:
%   Four possible dates of launch, in mjd2000 format, according to the type
%   of transfer (OO, OI, IO, II).
%
%AUTHOR
%Hadrien AFSA  
%
%--------------------------------------------------------------------------

    muSun=getAstroConstants('Sun', 'mu');

    launch_window=NaN(1,4);

    % Determines which planet is the first one (departure) and associate the
    % corresponding true anomaly
    % NOTE: here, planet 1 is not necessarily the innermost planet, but the
    % first planet of the leg
    if pl1<pl2 % Up transfer
        theta_pl1=theta_1;
        theta_pl2=theta_2;
        up_transfer=true;
    elseif pl1>pl2 % Down transfer
        theta_pl1=theta_2;
        theta_pl2=theta_1;
        up_transfer=false;
    else
        error('Error in find_launchWindow: first leg cannot be the same planet')
    end

    % Rate of the second (arrival) planet (to take account of its motion 
    % during the transfer)
    [~,~,sma_pl2]=planetConstants(pl2);
    n_pl2 = sqrt(muSun/(sma_pl2^3));

    % Goes through all the I/O in the order: OO OI IO II
    for i=1:4
        ToF=list_ToFs(i); % s

        % Computes the actual value of theta (on the full ellipse and not
        % only on the half)
        switch i
            case 1 % OO
                t1=theta_pl1;
                new_theta_pl2=theta_pl2;
            case 2 % OI
                t1=theta_pl1;
                new_theta_pl2=2*pi-theta_pl2;
            case 3 % IO
                t1=2*pi-theta_pl1;
                new_theta_pl2=theta_pl2;
            case 4 % II
                t1=2*pi-theta_pl1;
                new_theta_pl2=2*pi-theta_pl2;
        end
        % Computes the position of the arrival planet at the departure
        t2=wrapTo2Pi(new_theta_pl2-ToF*n_pl2);
        
        % Checks if pl2 is ahead of pl1 (rotation is anti-clockwise)
        % delta_theta is the angle between the innermost planet, Sun and the 
        % outermost planet. It is positive if the outermost planet is ahead
        % of the innermost one.
        if up_transfer
            % pl1 is the innermost planet
            if isAheadOf(t1,t2) % t2 is ahead of t1
                delta_theta=min(abs(t2-t1),abs(2*pi-t1+t2));
            else
                delta_theta=-min(abs(t2-t1),abs(2*pi-t2+t1));
            end
        else
            % pl2 is the innermost planet
            if isAheadOf(t1,t2) % t2 is ahead of t1
                delta_theta=-min(abs(t2-t1),abs(2*pi-t1+t2));
            else
                delta_theta=min(abs(t2-t1),abs(2*pi-t2+t1));
            end
        end

        % Finds the launch window date corresponding to the computed phase 
        % angle:
        % Loads the corresponding table (Enters the planets ID in the 
        % correct order (inner or outer)
        array_phase = phase_database{min(pl1,pl2), max(pl1,pl2)};

        % Finds the index for the closest value of the searched phase angle
        [~, idx]=min(abs(array_phase(:,2)-delta_theta));
            
        % Finds the launch date for the corresponding transfer type (I/O)
        launch_window(i) = array_phase(idx, 1);
    end    
end