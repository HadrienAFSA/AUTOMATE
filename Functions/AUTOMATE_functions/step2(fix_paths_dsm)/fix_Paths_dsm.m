function [final_fixed_Paths] = fix_Paths_dsm(Paths, Grid,max_reso_leg, max_reso_tot, max_dv,max_dv_per_DSM)
%fix_Paths_dsm.m - Fix paths 
%
%DESCRIPTION:
%Step 2 of the AUTOMATE algorithm, fixes the paths generated by Step 1 by
%checking if single flyby are possible, and by adding resonances
%
%INPUTS
%-Paths:
%   List of paths generated by generate_Paths.m
%-Grid:
%   Grid generated by generate_grid.m
%-max_reso_leg:
%   Maximum number of resonances allowed per leg
%-max_reso_tot:
%   Maximum number of resonances allowed totally
%-max_dv [km/s]:
%   Maximum delta V capability of the spacecraft
%
%OUTPUTS
%-final_fixed_Paths:
%   Cell containing the list of fixed paths, with the resonances [n,m,NÂ° leg]
%   alpha used if applicable and the list of DSM's dv for each flyby
%
%AUTHOR
%Hadrien AFSA
%
%--------------------------------------------------------------------------

    l_Paths=length(Paths);
    
    Paths_fixed=cell(l_Paths,2);
    idx_path=1;
    
    % Goes through all paths
    for i=1:length(Paths)

        %disp("#################");
        tic;

        seq=Paths{i};
        impossible_sequence=false;

        lseq = length(seq);
        
        seq_fixed=NaN(1,2);
        seq_fixed(1,:)=seq(1,:);
        seq_idx=2;
        
        % Stores all the resonances and alpha used
        list_reso_used=[]; 
        list_alpha_used=[];
        shift_reso=0;
        
        % Stores the total number of resonances used
        total_num_reso = 0;

        % Stores the remaining dv for DSMs
        remaining_dv=max_dv;
        % Stores DSMs used
        DSMs=zeros(1,1);
        dsm_idx=1;

        % Goes through all legs
        for j=2:lseq-1 
            %prec=seq(j-1,:);
            %curr=seq(j,:);
            %next=seq(j+1,:)
            % Finds first and second intersections
            inter1=check_intersectionGrid(seq(j-1,1), seq(j-1,2), seq(j,1), seq(j,2), Grid);
            inter2=check_intersectionGrid(seq(j,1), seq(j,2), seq(j+1,1), seq(j+1,2), Grid);

            % Gets the initial alpha (checks which column to get it from)
            if seq(j,1)<seq(j-1,1)
                alpha_i = inter1(2);
            elseif seq(j,1)>seq(j-1,1)
                alpha_i = inter1(5);
            else
                error("Error in fix_Paths 1");
            end

            % Gets objective alpha
            if seq(j,1)<seq(j+1,1)
                alpha_f = inter2(2);
            elseif seq(j,1)>seq(j+1,1)
                alpha_f = inter2(5);
            else
                error("Error in fix_Paths 2");
            end

            %disp("###################################")
           
            
            % Checks if single flyby can be achieved (no resonance needed)
            [bool_single, dv] = check_singleFlyby_dsm(alpha_i, alpha_f, seq(j,1), seq(j,2),max_dv_per_DSM);

            if bool_single
                %disp("Single ! ")
                % Single flyby can be achieved
                seq_fixed(seq_idx, :)=seq(j,:);
                seq_idx=seq_idx+1;
                DSMs(dsm_idx)=0;
                dsm_idx=dsm_idx+1;

            elseif dv<max_dv_per_DSM && dv<remaining_dv
                % Single flyby can be achieved with DSM
                remaining_dv=remaining_dv-dv;

                % Saves dv
                DSMs(dsm_idx)=dv;
                dsm_idx=dsm_idx+1;

                seq_fixed(seq_idx, :)=seq(j,:);
                seq_idx=seq_idx+1;
            else
                % Try to find resonance            
                if total_num_reso < max_reso_tot
                    if max_reso_leg==0
                        impossible_sequence=true;
                        break
                    else
                        %disp('###############');
                        % Find resonances available: how many are used,
                        % what are the alpha used, and what ratio are the
                        % resonances (n:m)
                        [n_reso, alpha_list, reso_used, dv_final]=check_Resonances_dsm(alpha_i, alpha_f, seq(j,1), seq(j,2),max_reso_leg, max_dv_per_DSM);

                        if n_reso==0 || dv_final>remaining_dv
                            % No possible path
                            impossible_sequence=true;
                            break
                        else
                            % Adds the resonances used in a matrix to be stored
                            tmp_reso_matrix=[];
                            for r=1:size(reso_used,1)
                                tmp_reso_matrix=[tmp_reso_matrix; [reso_used(r,:) j+shift_reso]];
                                shift_reso=shift_reso+1;
                            end
                            list_reso_used=[list_reso_used; tmp_reso_matrix];
                            list_alpha_used=[list_alpha_used; [alpha_list]];

                            % Adds the resonance flybys in the sequence as
                            % well as the DSMs
                            for reso=1:n_reso+1
                                seq_fixed(seq_idx, :)=seq(j,:);
                                seq_idx=seq_idx+1;
                                dsm_idx=dsm_idx+1;
                            end

                            DSMs(dsm_idx-1)=dv_final;

                            % Sums total resonances used
                            total_num_reso = total_num_reso+n_reso;

                            % Updates remaining dv
                            remaining_dv=remaining_dv-dv_final;
                        end
                    end
                else
                    impossible_sequence=true;
                    break
                end
            end

        end

        % Sequence including all the resonances
        seq_fixed(seq_idx, :)=seq(end,:);
        seq_idx=seq_idx+1;

        % Saves the sequences and its parameters
        if not(impossible_sequence)
            %seq_fixed
            Paths_fixed{idx_path,1}=seq_fixed;
            Paths_fixed{idx_path,2}=list_reso_used;
            Paths_fixed{idx_path,3}=list_alpha_used;
            Paths_fixed{idx_path,4}=DSMs;
            idx_path=idx_path+1;
    
        else
            %Paths_fixed=[Paths_fixed; {"Not possible"}];
        end

        if mod(i,50000)==0
            elapsed_time=toc;
            percent=(i/l_Paths)*100;
            remaining_time = round((l_Paths-i)*elapsed_time,0);
            hours_left=floor(remaining_time/3600);
            minutes_left=floor((remaining_time-hours_left*3600)/60);
            seconds_left=mod(remaining_time,60);

            fprintf("Fixing paths...: %d/%d (%g%%), ETA: %d h %d m %d s.\n", ...
                    i, l_Paths, round(percent, 1), hours_left,...
                    minutes_left, seconds_left);
        elseif i==size(Paths,1)
            fprintf("\nFixing paths finished!");
        end

    end



    final_fixed_Paths=Paths_fixed(~cellfun('isempty',Paths_fixed(:,1)),:);
    fprintf(" %d paths fixed.\n", size(final_fixed_Paths,1));
end

